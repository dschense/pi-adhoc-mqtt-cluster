#!/usr/bin/env python3
# pylint: disable=E1101, C0103, C0412, W0611
# -*- coding: utf-8 -*-
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_html_components as dhc

import plotly
import pandas as pd
import plotly.graph_objs as go
from dash.dependencies import Input, Output, Event, State
import visdcc

import json
from textwrap import dedent as d

import networkparser

import pprint

from graphinfo import Graphinfo
from influxdbhandler import Influxdbhandler


app = dash.Dash()

# If you are assigning callbacks to components
# that are generated by other callbacks
# (and therefore not in the initial layout), then
# you can suppress this exception by setting
# `app.config['suppress_callback_exceptions']=True`.
app.config['suppress_callback_exceptions']=True

graphinfo = Graphinfo(None,'time > now() - 5m')
influxdbhandler = Influxdbhandler()

styles = {
    'pre': {
        'border': 'thin lightgrey solid',
        'overflowX': 'scroll',
        'height': '200px',
    }
}
# styles = {
#     'pre': {
#         'border': 'thin lightgrey solid',
#         'overflowX': 'scroll',
#         'width': '70%',
#     }
# }

app.layout = dhc.Div([
    dhc.Div([
      visdcc.Network(id = 'net', 
                     options = dict(height= '600px', width= '100%',
                                    # physics={'barnesHut': {'avoidOverlap': 1,"damping": 0.4,"centralGravity": 0.3,"springConstant": 0.1,"springLength": 100,}}
                                    physics={'barnesHut': {'avoidOverlap': 1,"damping": 0.4,"centralGravity": 0.1,"springConstant": 0.04,}}
)),
], className='column', style={'float':'left','height': '600px', 'width': '67%'}),

    #   dcc.Input(id = 'label',
    #             placeholder = 'Enter a label ...',
    #             type = 'text',
    #             value = ''  ),
dcc.Interval(
    id='interval-component',
    interval=3*1000, # in milliseconds
    n_intervals=0
),

dhc.Div([
        dcc.Markdown(d("""
            **Selected Service**
        """)),
        # dhc.Pre(id='selected-service', style=styles['pre'])
        dhc.Div(id='selected-service')
    ], className='column', style={'float':'left','height': '600px', 'width': '33%'}),

# dhc.Div([
#         dcc.Markdown(d("""
#             **Selected Node**

#             Nodes and Edges:
#         """)),
#         dhc.Pre(id='selected-node', style=styles['pre'])
#     ], className='column', style={'float':'left', 'width': '50%'}),



# dhc.Div([
#         dcc.Markdown(d("""
#             **Services**

#             All sevices:
#         """)),
#         dhc.Pre(id='all-services', style=styles['pre'])
#     ], className='column', style={'float':'left', 'width': '50%'}),


# dhc.Div([
#         dcc.Markdown(d("""
#             **InfluxDB response**

#             Response of measurement select query:
#         """)),
#         dhc.Pre(id='measurement-query-response', style=styles['pre'])
#     ]),

html.Div([
        html.H4('Graph of selected measurement'),
        html.Div(id='live-update-text'),
        dcc.Graph(id='live-update-graph', animate=False),
        dcc.Interval(
            id='graph-interval-component',
            interval=1*1000, # in milliseconds
            n_intervals=0
        )
    ]),

], className='row',)



# @app.callback(
#     Output('selected-node', 'children'),
#     [Input('net', 'selection')])
# def display_click_data(selection):
#     # print('callback blablubb')
#     if not selection:
#         return 'Please select a node.'
#     return json.dumps(selection, indent=2)


@app.callback(
    Output('selected-service', 'children'),
    [Input('net', 'selection')])
def display_selected_service(selection):
    # print('callback blablubb')
    if not selection:
        return 'Please select a service.'
    return networkparser.show_selected_service(selection)

# @app.callback(
#     Output('measurement-query-response', 'children'),
#     [Input('graph-interval-component', 'n_intervals')])
# def display_measurement_query_response(n):
#     # print('callback blablubb')
#     return pprint.pformat(influxdbhandler.getmeasurement(graphinfo.getmeasurement(),"notinuseyettime > now() - 5s"))


# @app.callback(
#     Output('all-services', 'children'),
#     [Input('interval-component', 'n_intervals')])
# def display_all_services(n):
#     # print('callback blablubb')
#     # if not selection:
#     #     return 'Please select a node.'
#     # return json.dumps(selection, indent=2)
#     # return networkparser.getservices()
#     # services = networkparser.getservices()
#     # for service in services:
#     #     return service
#     # return pprint.pformat(networkparser.getservices())
#     return networkparser.printservices(networkparser.getservices())


@app.callback(
            Output('net', 'data'),
              [Input('interval-component', 'n_intervals')])
def update_metrics(n):
    return networkparser.parsenetwork()

# @app.callback(
#             Output('label', 'value'),
#               [Input('interval-component', 'n_intervals')])
# def update_mqtt_output(n):
#     return networkparser.getservices_json()




@app.callback(Output('live-update-text', 'children'),
              [dash.dependencies.Input('service-measurements-dropdown', 'value')])
def update_graph_text(value):
    # lon, lat, alt = satellite.get_lonlatalt(datetime.datetime.now())
    measurement_id = value
    service_id = measurement_id.split('---')[0]
    service = networkparser.getservice(service_id)
    graphinfo.setmeasurement(service['measurements'][measurement_id])
    # pprint.pprint(graphinfo.getmeasurement())
    style = {'padding': '5px', 'fontSize': '16px'}
    return [
        html.Span('Measurement name: {}'.format(graphinfo.measurement['measurement_name']), style=style),
        # html.Span('Latitude: {0:.2f}'.format(lat), style=style),
        # html.Span('Altitude: {0:0.2f}'.format(alt), style=style)
    ]


@app.callback(Output('live-update-graph', 'figure'),
              [Input('graph-interval-component', 'n_intervals')])
def update_graph_scatter(n):
    # try:
        # conn = sqlite3.connect('twitter.db')
        # c = conn.cursor()
        measurement = graphinfo.getmeasurement()
        if measurement is None:
            layout = go.Layout(showlegend=True, title='measurement name text',xaxis={'title':'x-Legend text'},yaxis={'title':'y-Legend text'})
            return {'data':[],'layout':layout}
        df = influxdbhandler.getmeasurement(measurement,"time > now() - 10s")

        if df is None:
            layout = go.Layout(showlegend=True, title='measurement name text',xaxis={'title':'x-Legend text'},yaxis={'title':'y-Legend text'})
            return {'data':[],'layout':layout}
        
        # df.sort_values('unix', inplace=True)
        # df['sentiment_smoothed'] = df['sentiment'].rolling(int(len(df)/2)).mean()

        # df['date'] = pd.to_datetime(df['unix'],unit='ms')
        # df.set_index('date', inplace=True)

        # # df = df.resample('1min').mean()
        # df.dropna(inplace=True)
        data_list = []
        X = df.index
        min_Y = None
        max_Y = None
        for field in measurement['measurement_fields']:
            Y = df[field['measurement_field_id']]
            if min_Y is None:
                min_Y = min(Y)
                max_Y = max(Y)
            else:
                
                min_Y = min(min_Y,min(Y))
                max_Y = max(max_Y,max(Y))
            new_data = plotly.graph_objs.Scatter(
                x=X,
                y=Y,
                name=field['measurement_field_name'],
                mode= 'lines+markers'
                )
            data_list.append(new_data)
        # Y = df.sentiment_smoothed
        # Y = df[measurement['measurement_fields'][0]['measurement_field_id']]
        # X = df.index
        # # Y = df.sentiment_smoothed
        # Y = df['pitch']

    
        # data = plotly.graph_objs.Scatter(
        #         x=X,
        #         y=Y,
        #         name='Scatter',
        #         mode= 'lines+markers'
        #         )
        # print('just before return graph data')
        return {
                'data': data_list,
                'layout' : go.Layout(
                                    showlegend=True,
                                    xaxis=dict(range=[min(X),max(X)],
                                                title='Time (UTC)'
                                                ),
                                    yaxis=dict(range=[min_Y,max_Y],
                                                title=measurement['measurement_fields'][0]['measurement_field_unit']
                                                ),
                                    title='Measurement: {}'.format(measurement['measurement_name'])
                                    )
                }
        # return {'data': data_list,'layout' : go.Layout(xaxis=dict(range=[min(X),max(X)]),
        #                                             yaxis=dict(range=[min_Y,max_Y]),
        #                                             title='Measurement: {}'.format(measurement['measurement_name']))}
        # return {'data': [data],'layout' : go.Layout(xaxis=dict(range=[min(X),max(X)]),
        #                                             yaxis=dict(range=[min(Y),max(Y)]),
        #                                             title='Term: {}'.format(measurement['measurement_name']))}

    # except Exception as e:
    #     print(e)
    #     # with open('errors.txt','a') as f:
        #     f.write(str(e))
        #     f.write('\n')



if __name__ == '__main__':
    # app.run_server()
    app.run_server(debug=True, host='0.0.0.0')
    # app.run_server(debug=False, host='0.0.0.0')